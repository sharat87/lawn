# enable color support
if [[ -x /usr/bin/dircolors ]]; then
    [[ -r ~/.dircolors ]] && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

alias ll='ls -l --almost-all --classify --human-readable'
alias la='ls --almost-all'
alias l='ls --classify'

alias le=less

alias xg='xargs -I%'

alias gr='grep '
alias grp='grep --perl-regex'

alias rmv='rm -v'
alias mvv='mv -v'
alias cpv='cp -v'
alias lnv='ln -v'

# `so` means `source` in vim :)
alias so='source'

# Hate typing `gnone-open`. Just hate it. Nothing personal.
alias o='gnome-open'

alias na='nautilus'

alias v='gvim'
alias v.='vim'

alias epoch='date +%s'

# svn shortys
alias sin='s info'
alias sst='s st'
alias sdi='s diff'
alias sci='s ci'
alias sco='s co'
alias sup='s up'
alias sxp='s export'
alias slo='s log'
alias sre='s revert'
alias sbl='s blame'
alias ssw='s switch'
alias sad='s add'

# Even two is too much sometimes :)
alias h='hg'

alias ipy='ipython'
alias py='bpython'
alias pipr='pip install -r requirements.txt'

alias pbcopy='xsel --clipboard --input'
alias pbpaste='xsel --clipboard --output'

alias tree='tree -C --charset utf-8'

# Command to quickly edit the aliases file
alias eal='v. ~/lawn/shell/custom-configs/aliases && source ~/lawn/shell/custom-configs/aliases'

alias ht=htop

alias sp='rlwrap sqlplus'

alias f='fab'
alias m='make'

alias fn=find
alias ff='find -type f -iname'
alias fd='find -type d -iname'

# Various javas and ants
alias j4="JAVA_HOME=$JAVA_4_HOME PATH=$JAVA_4_HOME/bin:$PATH"
alias j5="JAVA_HOME=$JAVA_5_HOME PATH=$JAVA_5_HOME/bin:$PATH"
alias j6="JAVA_HOME=$JAVA_6_HOME PATH=$JAVA_6_HOME/bin:$PATH"
alias ant4='j4 rn ant'
alias ant5='j5 rn ant'
alias ant6='j6 rn ant'

# An alias to antigen.
alias a.=antigen

###
# Utility functions/commands
###

# Check if the given files (as arguments) are the same files, using md5 hashing.
are-same-files () {
    local quite=false

    if [[ $1 == -q ]]; then
        quite=true
        shift
    fi

    if [[ "$(md5sum "$@" | cut -d' ' -f1 | sort -u | wc -l)" == 1 ]]; then
        $quite || echo Yes. They are the same, according to md5 hashing.
    else
        $quite || echo No. They are NOT the same, according to md5 hashing.
        return 1
    fi
}

gman () {
    yelp "man:$1" &
}

compdef "_man" gman

ec () {
    easytether connect &
    sleep 1s
    sudo dhclient easytether0
    notify-send "EasyTether" "Connection established"
}

# Extract any archive
ex () {
    if [[ ! -f $1 ]]; then
        echo "'$1' is not a valid file."
    fi
    case $1 in
        *.tar.bz2)   tar xjf $1;;
        *.tar.gz)    tar xzf $1;;
        *.bz2)       bunzip2 $1;;
        *.rar)       rar x $1;;
        *.gz)        gunzip $1;;
        *.tar)       tar xf $1;;
        *.tbz2)      tar xjf $1;;
        *.tgz)       tar xzf $1;;
        *.zip)       unzip $1;;
        *.Z)         uncompress $1;;
        *.7z)        7z x $1;;
        *)           echo "'$1' cannot be extracted via extract()";;
    esac
}

# Run a command and notify when done
rn () {
    if $@
    then
        notify-send 'Shell' "$1 finished successfully"
    else
        notify-send 'Shell' "$1 has failed"
    fi
}

# Rerun a command continuously. Tip by @climagic
rr () {
    while true; do
        $1
        sleep ${2:-1}
    done
}

ca () {
    cdargs "$1" && cd "`cat "$HOME/.cdargsresult"`"
}

# Update vimfiles and lawn
lawn-files-update () {
    (cd ~/lawn && f)
    notify-send "lawn-mowing finished"
}

#----------------------------------------
# aptitude utilities
#----------------------------------------

# Master aptitude command.
a () {
    local cmd=$1

    case "$cmd" in
        changelog|download|help|show|search|versions|why|why-not)
            aptitude "$@"
            ;;
        *)
            sudo aptitude "$@"
            ;;
    esac
}

# show command
alias aw='aptitude show'

# install command
ai () {
    if sudo aptitude install "$@"; then
        notify-send "aptitude" "$1 installation finished"
    else
        notify-send "aptitude" "Error installing $1"
    fi
}

compdef "_a install" ai

# purge command
ap () {
    if sudo aptitude purge "$@"; then
        notify-send "aptitude" "$1 purged"
    else
        notify-send "aptitude" "Error purging $1"
    fi
}

compdef "_a purge" ap

# remove command (ar is the archive command)
ad () {
    if sudo aptitude remove "$@"; then
        notify-send "aptitude" "$1 removed"
    else
        notify-send "aptitude" "Error removing $1"
    fi
}

compdef "_a remove" ad

# update command
au () {
    sudo aptitude update "$@"
    notify-send "aptitude" "Update finished"
}

compdef "_a update" au

_a () {
    words=( aptitude $1 $words[2,-1] )
    (( CURRENT++ ))
    shift
    _aptitude "$@"
}

#----------------------------------------
# Version control utils
#----------------------------------------

# Because just svn wouldn't cut it!
s () {
    if [[ $1 == "diff" ]]; then
        svn "$@" | colordiff
    elif [[ $1 == "log" ]]; then
        svn "$@" | discoball '^r\d+ \| ([-_a-z]+) \|'
    elif [[ $1 == "st" || $1 == "status" ]]; then
        svn "$@" | discoball '^\S'
    elif [[ $1 == "info" ]]; then
        svn "$@" | discoball -g '^[a-zA-Z ]*:'
    else
        svn "$@"
    fi
    notify-send "Subversion $1 finished"
}

cv () {
    if cvs -d ':extssh:cvs:/usr/local/cvs' "$@"
    then
        notify-send "CVS Success" "CVS $1 exited successfully"
    else
        notify-send "CVS Failure" "CVS $1 seem to have failed"
    fi
}

alias cs="c -qq -n up 2>&1 | awk '/^U / { next } /no longer in/ { print \"? \" \$3; next } { print }'"

#----------------------------------------
# Miscellaneous
#----------------------------------------

# Open a mail in mutt for a given message-id
mutt-open-mail-id () {
    mutt -e "push /~i$1\no"
}

# My default tasks
t () {
    python ~/.t.py --task-dir ~/Dropbox --list tasks "$@" | discoball '\+\S+'
}

# My work tasks
k () {
    python ~/.t.py --task-dir ~/Dropbox --list tasks-work "$@" \
        | discoball '^\S+\s+-' '\+\S+' 'mail:'
}

# Take the message-id from the task and display the message
km () {
    local mail_id="$(python ~/.t.py --task-dir ~/Dropbox --list tasks-work \
            | sed -n "s/^$1\s\+- .*mail://p")"
    if [[ -z $mail_id ]]; then
        echo No task with that id or the task has no attached mail.
        return 1
    else
        mutt-open-mail-id "$mail_id"
    fi
}

# Project specific bugs/todos
b () {
    python ~/.t.py --task-dir . --list todo | discoball '\+\S+'
}

# Aliases for my task manager
alias t.f='t -f'
alias t.r='t -r'
alias k.f='k -f'
alias k.r='k -r'

# cd to an ancestral directory
cu () {

    if [[ -z $1 ]]; then
        echo Please give a dirname
        return 1
    fi

    local d="$(dirname "$(pwd)")"

    while [[ "$(basename "$d")" != $1 ]] && [[ $d != "/" ]]; do
        d="$(dirname "$d")"
    done

    if [[ $d == "/" ]]; then
        echo \"$1\" is not present in current path
    else
        cd "$d"
    fi

}

_cu () {
    compadd $(dirname "$PWD" | tr / \\n)
}

compdef _cu cu

copy-path () {
    local apath=
    if [[ -d "$1" ]]; then
        apath=$(cd "$1" && pwd)
    elif [[ -f "$1" ]]; then
        apath="$PWD/$1"
    fi
    echo -n $apath | pbcopy
    echo $apath
}

# A command to quickly open and start everything needed to start working on a
# project.
i () {
    project="$1"
    starter="$HOME/.starters/$project.sh"
    if [[ -f "$starter" ]]; then
        export PROJECT=$project
        source "$starter"
    else
        echo "Project $project does not exist."
        echo -n "Create it? [y|N] "
        if read -q; then
            $EDITOR "$HOME/.starters/$project.sh"
        fi
    fi
}

# Project loader autocomplete
_i () {
    compadd $(ls --color=never ~/.starters | sed 's/\.sh$//')
}

compdef _i i

# The usual `./configure`, `make` and `make installl` automation.
auto-install () {
    app_name="${PWD##*/}"
    install_dir="$HOME/apps/$app_name"

    if [[ ! -f "./configure" ]]; then
        echo "There doesn't seem to be an app here."
        return 1
    fi

    echo Installing $app_name to $install_dir

    if ! ./configure --prefix="$install_dir" "$@"; then
        msg='*** Error with `./configure`. Please correct and retry.'
        return 1

    elif ! make; then
        msg='*** Error with `make`. Please check and retry.'
        return 2

    elif ! make install; then
        msg='*** Error with `make install`. Please check and retry.'
        return 3

    elif [[ -d "$install_dir/bin" ]]; then
        export PATH="$install_dir/bin:$PATH"
    fi

    echo "$msg"
    notify-send "$app_name finished" "${msg:-Installation complete.}"
}

# vim: se ft=sh :
